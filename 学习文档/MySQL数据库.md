

# MySQL数据库

## 一、MySQL通配符模糊查询(%,_)

### 1-1. 通配符的分类

1、"%" 百分号通配符: 表示任何字符出现任意次数 (可以是0次)。

2、"_" 下划线通配符:表示只能匹配单个字符,不能多也不能少,就是一个字符。当然，也可以like "陈"，数量不限。

3、like操作符:LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较；但如果like后面没出现通配符，则在SQL执行优化时将 like 默认为 “=”执行

> 注意: 如果在使用like操作符时，后面没有使用通用匹配符（%或_），那么效果是和“=”一致的。在SQL执行优化时查询优化器将 like 默认为 “=”执行,SELECT * FROM movies WHERE movie_name like '唐伯虎';只能匹配movie_name=“唐伯虎”的结果,而不能匹配像“唐伯虎点秋香”或“唐伯虎点香烟”这样的结果.

### 1-2. 通配符的使用

#### 1) % 通配符

```sql
-- 模糊匹配 含有“网”字 的数据
SELECT * from app_info where appName like '%网%'; 
-- 模糊匹配 以“网”字结尾 的数据
SELECT * from app_info where appName like '%网'; 
-- 模糊匹配 以“网”字开头 的数据
SELECT * from app_info where appName like '网%'; 
-- 精准匹配，appName like '网' 等同于：appName = '网'
SELECT * from app_info where appName = '网'; 
SELECT * from app_info where appName like '网'; 
-- 模糊匹配含有“xxx网xxx车xxx”的数据,如："途途网约车司机端、网络约车平台"
SELECT * from app_info where appName like '%网%车%';
```

#### 2) _ 通配符

```sql
-- 查询以“网”为结尾的，长度为三个字的数据，如："链家网"   --注意：'%__网、__%网'  等同于 '%网'
SELECT * from app_info where appName like '__网';
-- 查询前三个字符为XX网，后面任意匹配，如："城通网盘、模具网平台"
SELECT * from app_info where appName like '__网%';
-- 模糊匹配含有“xx网x车xxx”的数据，如："携程网约车客户端"
SELECT * from app_info where appName like '__网_车%';
```

> 注意事项:   
>
> 1、注意大小写,在使用模糊匹配时,也就是匹配文本时,**MySQL默认配置是不区分大小写的**。当你使用别人的MySQL数据库时，要**注意是否区分大小写**，是否区分大小写<u>取决于用户对MySQL的配置方式</u>.如果是区分大小写,那么像Test12这样记录是不能被"test__"这样的匹配条件匹配的。
>
> 2、注意**尾部空格**,"%test"是不能匹配"test "这样的记录的。
>
> 3、注意NULL,%通配符可以匹配任意字符,但是**不能匹配NULL**,也就是说SELECT * FROM blog where title_name like '%';是匹配不到title_name为NULL的的记录。

### 1-3. 技巧与建议:

正如所见，MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长，消耗更多的内存等资源。这里给出一些使用通配符要记住的技巧。

- 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。
- 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。因为MySQL在where后面的执行顺序是从左往右执行的，如果把通配符置于搜索模式的开始处（最左侧），搜索起来是最慢的(因为要对全库进行扫描)。
- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。

有细心地朋友会发现，如果数据中有“%”、“_”等符号，那岂不是和通配符冲突了？

```sql
SELECT * from app_info where appName LIKE '%%%';
SELECT * from app_info where appName LIKE '%_%';
```

确实如此，上面面两条SQL语句查询的都是全表数据，而不是带有"%"和"_"的指定数据。**这里需要加 ESCAPE 关键字进行转义**。

如下，ESCAPE 后面跟着一个字符，里面写着什么，MySQL就把那个符号当做转义符，一般我就写成"/"；然后就像 C语言中转义字符一样 例如 ‘\n’,’\t’, 把这个字符写在你需要转义的那个%号前就可以了；

```sql
SELECT * from app_info where appName LIKE '%/_%' ESCAPE '/'; 
```


但是这种情况有没有更高端点的解决办法呢？能让检查你代码的同事或领导对你刮目相看那种~~

当然，下面我们就来看看MySQL的第二类模糊匹配方式 --- 内置函数查询

## 数据去重

在 MySQL 中，你可以使用 `DISTINCT` 关键字和 `GROUP BY` 语句来进行去重操作。如果你想根据 `K6` 和 `K7` 列进行去重，可以尝试以下 SQL 查询：

```
sqlCopy code
SELECT DISTINCT K6, K7, * FROM your_table_name;
```

这将会选择唯一的 `K6` 和 `K7` 列的组合，并显示这些组合对应的完整行数据。`your_table_name` 是你实际的表名，替换为你所使用的表名。

如果你只关心这两列的唯一组合而不需要其他列的数据，可以不使用 `*`，像这样：

```
sqlCopy code
SELECT DISTINCT K6, K7 FROM your_table_name;
```

这样就会返回 `K6` 和 `K7` 列的唯一组合。

记得备份数据或者在执行任何删除操作之前确认你的查询结果是符合预期的。

```sql
SELECT MAX(ID), K6, K7, * 
FROM FROM sense_data.TB_REPORT where 1 = 1 and source_id = 390000028
GROUP BY K6, K7;
```

## 【SQL】区间（条件）分组统计

### 简介

很多时候，我们都使用group by 进行分组，count(*)进行统计，两者结合可以进行聚合统计。

假设我们有这样一张煤矿数据库表

```text
table name: coalmine
columns: id(煤矿ID, bigint), prod_status(生产状态,varchar), prod_capacity(产能,decimal)
```

### 需求：统计各生产状态的煤矿数量

学过SQL的人一眼就看出来，这是一个非常基础的问题。我们只需要按照prod_status进行分组进行聚合统计即可。大致可以写如下的sql：

```text
select prod_status as name, count(*) as num from coalmine group by name;
```

可以得到如下的输出：

```text
name | num
停产  377
停建  360
关闭  31
准备  1
在建  89
正在复产    3
生产  463
生产/在建   15
生产/试运转  12
试运转 1
```

非常完美，我们得到了我们想要的数据。

但是现在有了新的需求：统计产能在30以下，30~90，90以上的煤矿数量有多少。现在我们遇到了难题，因为产能字段(prod_capacity)是一个数值，同时统计的依据是一个区间，我们不能单纯的将其作为group by的对象进行操作。

```text
select prod_capacity as name, count(*) as num from coalmine group by name;
```

这样做的结果，只是按数值进行分组统计。

那么，该怎么办呢？

### 区间统计（解法一）

有点基础的读者不难看出，我们可以使用mysql关键字 **sum** 以及 **if** 进行操作，大致可以写出如下的SQL。

```text
select
    sum(if(c.prod_capacity is null or c.prod_capacity < 30, 1, 0)) as less30,
    sum(if(c.prod_capacity >= 30 and c.prod_capacity <= 90, 1, 0)) as between39,
    sum(if(c.prod_capacity > 90, 1 , 0)) as gather90
from coalmine c inner join enterprise e on c.enterprise_id = e.id;
```

> c.prod_capacity is null 可以认为prod_capacity字段为空时，认为煤矿的产能低于30.

**sum** 以及 **if** 的使用方法可参阅网上教程。执行完毕后，我们可以得到如下的结果：

```text
less30 | between39 | than90
 1033   330          25
```

看起来似乎很美好，只不过没有使用分组排序稍有欠缺，导致最终结果是以一行的方式呈现，这回导致我们在应用程序里面进行实体映射（例如mybatis）时，只能使用扁平结构进行对应（例如Map），这和统一的分组映射实体出现矛盾。当然对于解决问题的结果来说这是无伤大雅的，最终我们还会讲最完美的解法，在此之前，我们先看另一种解决方案。

### 区间统计（解法二）

mysql有众多函数可以帮助我们完成各种各样的任务，只要我们仔细研究，很多冗余的SQL可以简化的漂亮，关于区间统计，其实还有专门的处理函数，他们分别是 `interval` 以及 `ele`。我们来看看他们的用法：

```text
INTERVAL(N,N1,N2,N3,...) INTERVAL()函数进行比较列表(N1，N2，N3等等)中的N值。该函数如果N<N1返回0，如果N<N2返回1，如果N<N3返回2 等等。如果N为NULL，它将返回-1。列表值必须是N1<N2<N3的形式才能正常工作。

ELT(N,str1,str2,str3,...) 如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。
```

基于此，我们可以写出更漂亮的SQL

```text
select elt(interval(c.prod_capacity,0,30,90, 100000), 'less30', 'between39', 'than90') as name, count(*)
from coalmine c group by name;
```

但显然，查询的结果受限非常之大，interval是半区间方式，（即大于等于前者小于后者），这样会导致运用场景非常之有限。当然可以通过其他方式进行优化，但是已经如使用sum、if方式来得方便灵活。

但前者也有问题，就是查询的结果并不是多条记录展示，这样在很多业务系统中，进行bean映射的时候，只能采取hashmap方式进行结果映射。显然其原理还是分组统计，我们希望结果是以多行的形式展示。那么，该如何办到呢？

### 区间统计（解法三）

可以看到，既然分组的逻辑是一种`if else`形式的，我们可不可以在mysql里找到这种逻辑的关键字呢？显然是有的，那便是 `case`语句。以下是其官方文档:

```text
Syntax:

CASE value WHEN [compare_value] THEN result 
[WHEN [compare_value] THEN result ...] 
[ELSE result] 
END

或者

CASE WHEN [condition] THEN result 
[WHEN [condition] 
THEN result ...] 
[ELSE result] 
END
```

金风玉露一相逢，这便是我们要的东西，仔细琢磨一番，可以写出如下的SQL

```text
select 
    case 
      when c.prod_capacity is null or c.prod_capacity < 30 then 'less30' 
      when c.prod_capacity >= 30 and c.prod_capacity <=90 then 'less39'
      when c.prod_capacity > 90 then 'than90'
    end 
    as name, 
    count(*) as num
from coalmine c
group by name;
```

返回结果如下所示：

```text
name | num
less30  1033
less39  330
than90  25
```

### 结语

可以看到，使用case关键字不仅得到了我们想要的结果形式，同时他提供了更灵活的处理逻辑，不论是区间分组亦或是其他的非正常方式，我们都可以定义自己的处理逻辑，将业务上需要归为一组的数据输出(then)为同样的值，然后进行分组。






原文链接：https://blog.csdn.net/qq_39390545/article/details/106414765

## 数据库的数据太多了怎么办，一个表有一亿个数据（特别大的访问量到数据库上）？分库分表？

**1.使用索引**

     应尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。

**2.优化 SQL 语句**

     2.1 **通过 explain(查询优化神器)用来查看 SQL 语句的执行效果**， 可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通 常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句， 把关 键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news;      2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代 替“*” ， 不要返回用不到的任何字段。      2.3 不在索引列做运算或者使用函数。      2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和 带宽浪费。

**3.优化数据库对象**

3.1 **优化表的数据类型**     使用 procedure analyse()函数对表进行分析， 该函数可以对表 中列的数据类型提出优化建议。 能小就用小。 表数据类型第一个原 则是： **使用能正确的表示和存储数据的最短类型**。 这样可以减少对 磁盘空间、 内存、 cpu 缓存的使用。 使用方法： select * from 表名 procedure analyse(); 3.2 **对表进行拆分**     通过拆分表可以提高表的访问效率。 有 2 种拆分方法： **1.垂直拆分：** **把主键和一些列放在一个表中， 然后把主键和另外的列放在另 一个表中。** 如果一个表中某些列常用， 而另外一些不常用， 则可以 采用垂直拆分。     2.**水平拆分：** **根据一列或者多列数据的值把数据行放到二个独立的表中。** 3.3 **使用中间表来提高查询速度**     创建中间表， 表结构和源表结构完全相同， 转移要统计的数据 到中间表， 然后在中间表上进行统计， 得出想要的结果。

**4.硬件优化**

4.1 CPU 的优化      选择多核和主频高的 CPU。 4.2 内存的优化      使用更大的内存。 将尽量多的内存分配给 MYSQL 做缓存。 4.3 磁盘 I/O 的优化

4.3.1 使用磁盘阵列      RAID 0 没有数据冗余， 没有数据校验的磁盘陈列。 实现 RAID 0 至少需要两块以上的硬盘， 它将两块以上的硬盘合并成一块， 数据 连续地分割在每块盘上。      RAID1 是将一个两块硬盘所构成 RAID 磁盘阵列， 其容量仅等于 一块硬盘的容量， 因为另一块只是当作数据“镜像”。      使用 RAID-0+1 磁盘阵列。 RAID 0+1 是 RAID 0 和 RAID 1 的组 合形式。 它在提供与 RAID 1 一样的数据安全保障的同时， 也提供了 与 RAID 0 近似的存储性能。

4.3.2 调整磁盘调度算法      选择合适的磁盘调度算法， 可以减少磁盘的寻道时间。

**5.MySQL 自身的优化**

     对 MySQL 自身的优化主要是对其配置文件 my.cnf 中的各项参数 进行优化调整。 如指定 MySQL 查询缓冲区的大小， 指定 MySQL 允 许的最大连接进程数等。

**6.应用优化**

**6.1 使用数据库连接池**

**6.2 使用查询缓存**    

它的作用是存储 select 查询的文本及其相应结果。 如果随后收到 一个相同的查询， 服务器会从查询缓存中直接得到查询结果。 查询 缓存适用的对象是更新不频繁的表， 当表中数据更改后， 查询缓存 中的相关条目就会被清空。

**2.主从复制， 读写分离， 负载均衡**

目前，大部分的主流关系型数据库都提供了主从复制的功能，通过配置两台（或多台） 数据库的主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站可 以利用数据库的这一功能，**实现数据库的读写分离，从而改善数据库的负载压力**。**一个系 统的读操作远远多于写操作，因此写操作发向 master，读操作发向 slaves 进行操作**（简 单的轮循算法来决定使用哪个 slave）。      利用数据库的读写分离，**Web 服务器在写数据的时候，访问主数据库（Master），主 数据库通过\*主从复制机制\*将数据更新同步到从数据库（Slave），这样当 Web 服务器读数 据的时候，就可以通过从数据库获得数据。这一方案使得在大量读操作的 Web 应用可以轻 松地读取数据，而主数据库也只会承受少量的写入操作**，还可以实现数据热备份，可谓是 一举两得的方案。

**3.1 复制概述**

复制是指将主数据库的DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。

MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。

**3.2 复制原理**

MySQL 的主从复制原理如下。

![img](pic/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/v2-2a011346f6505138609d4aa498ffbda6_1440w.webp)

从上层来看，复制分成三步：

- Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。
- 主库推送二进制日志文件 Binlog 到从库的中继日志 Relay Log 。
- slave重做中继日志中的事件，将 Master 上的改变反映到它自己的数据库中。所 以两端的数据是完全一样的。

从图中可以看出， Slave 服务器中有一个 SQL 线程(SQL Thread)从中继日志读 取事件， 并重做其中的事件， 从而更新 Slave 的数据， 使其与 Master 中的数据一致。 只要 该线程与 I/O 线程保持一致，中继日志通常会位于 OS 的缓存中，所以中继日志的开销很小。

**3.3 复制优势**

MySQL 复制的有点主要包含以下三个方面：

- 主库出现问题，可以快速切换到从库提供服务。
- 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。
- 可以在从库中执行备份，以避免备份期间影响主库的服务。

### **主从复制的几种方式：**

1. 同步复制     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，必须等待验证*所 有的从服务器*的更新数据是否已经复制到其中，之后才可以自由处理其它进入的事务处理 请求。
2. 异步复制     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，无需等待验证更 新数据是否已经复制到从服务器中，就可以自由处理其它进入的事务处理请求。
3. 半同步复制     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，只需等待验证*其 中一台从服务器*的更新数据是否已经复制到其中，就可以自由处理其它进入的事务处理请 求，其他的从服务器不用管

**3. 数据库分表， 分区， 分库**

**分表：**

通过拆分表可以提高表的访问效率。 有 2 种拆分方法： **1.垂直拆分：** **把主键和一些列放在一个表中， 然后把主键和另外的列放在另 一个表中。** 如果一个表中某些列常用， 而另外一些不常用， 则可以 采用垂直拆分。     2.**水平拆分：** **根据一列或者多列数据的值把数据行放到二个独立的表中。**

**分区**就是把一张表的数据分成多个区块，**这些区块可以在一个磁盘上，也可以在不同 的磁盘上**，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，**多块硬盘同 时处理不同的请求，从而提高磁盘 I/O 读写性能**，实现比较简单。 包括水平分区和垂直分 区。 **分库**是**根据业务不同把相关的表切分到不同的数据库中**，比如 web、bbs、blog 等库。